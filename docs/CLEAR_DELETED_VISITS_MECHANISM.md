# Механізм «Очистити видалені візити» (clear-deleted-visits)

Цей документ описує, як працює очищення консультації та платного запису, коли візиту вже немає в Altegio, і чому очищені дані не повертаються в таблиці після refetch.

---

## 0. Як ми вирішили питання «видаляється, але знову з’являється»

**Проблема:** консультації, видалені в Altegio (візиту немає — 404), після очищення знову з’являлись у таблиці Direct. Користувач бачив дату й майстра, хоча в API їх вже не було.

**Причина:** кілька факторів одночасно:
1. **Авто-refetch кожні 30 с** — `loadClients()` підставляв відповідь API в таблицю; якщо API повертав застарілі дані (кеш, репліка), старий запис знову відображався.
2. **Вебхуки Altegio** — могли повторно надсилати події по старому (вже видаленому) запису й перезаписувати консультацію в БД.
3. **Sync / cron** — `sync-visit-history`, `sync-paid-service-dates` тощо читали дані з Altegio API й знову могли записати консультацію.

**Рішення (багаторівневий захист):**

| Рівень | Що робимо |
|--------|------------|
| **1. Пауза авто-refresh** | Після очищення на **2 хвилини** не викликаємо `loadClients()` з інтервалу 30 с. Таблиця не перезаписується з API. |
| **2. Merge при refetch** | Перед `setClients()` зливаємо відповідь API з `recentlyClearedVisitsRef` (ключі: altegioClientId, clientId, instagramUsername). Для клієнтів, очищених протягом **1 години**, примусово обнуляємо поля консультації в об’єктах — навіть якщо API повернув старі дані. |
| **3. Позначка в БД** | Поле **`consultationDeletedInAltegio`** = true. Вебхуки та sync/cron **не перезаписують** консультацію, якщо цей прапорець встановлено. Стан «видалено» зберігається до появи **нового** запису в Altegio. |
| **4. UI** | У колонці «Консультація» для клієнтів з `consultationDeletedInAltegio = true` показується «Видалено в Altegio» замість порожньої комірки — зрозуміло, що запис був і його видалили. |

У результаті консультація, очищена через відсутність візиту в Altegio, **не повертається** ні через refetch, ні через вебхуки, ні через sync — і користувач чітко бачить, що вона видалена.

---

## 1. Мета

У Direct-таблиці показуються **дата консультації** та **платний запис** з нашої БД. Іноді візит у Altegio видаляють (запис скасовано, перенесено тощо), а в БД залишаються старі поля. Механізм:

- перевіряє по **Altegio API** (GET /records, GET /visits), чи існує ще відповідний візит;
- якщо візиту **немає (404)** — очищає в БД поля консультації та/або платного запису;
- на фронті після очищення **не показує** ці дані знову навіть коли спрацьовує авто-оновлення (refetch кожні 30 с).

---

## 2. Як запустити (користувач)

1. Відкрити сторінку **Direct** та натиснути кнопку відкриття адмін-інструментів.
2. В адмін-панелі обрати кнопку **«Перевірити візити в Altegio та очистити видалені»**.
3. У prompt ввести **Altegio ID клієнта** (`altegioClientId`) — той самий, що в картці клієнта в Altegio.
4. Після успіху з’являється повідомлення типу: «Очищено: консультацію (візиту немає в Altegio).» Таблиця одразу оновлюється: дата консультації/майстер зникають у відповідному рядку (і в усіх дублікатах за цим клієнтом).

**Важливо:** ідентифікатор — саме **Altegio Client ID**, а не наш внутрішній `id` клієнта в Direct. У клієнта може не бути Instagram, але **altegioClientId** завжди є, якщо клієнт прив’язаний до Altegio.

---

## 3. Бекенд: endpoint `POST /api/admin/direct/clear-deleted-visits-for-client`

### Вхід

- **Body:** `{ "altegioClientId": number }` — ID клієнта в Altegio.
- Авторизація: кука `admin_token` або CRON-секрет.

### Логіка

1. Знаходиться один запис у БД: `directClient` з `altegioClientId === altegioClientId`.
2. **Платний блок:** якщо збережено `paidServiceVisitId` і GET візиту в Altegio повертає 404 — платний блок очищається (дата, visitId, recordId, breakdown тощо).
3. **Записи клієнта:** виклик **GET /records** по `altegioClientId`, фільтрація на консультації та платні записи. Для кожного унікального `visit_id` викликається **GET /visits/{visit_id}**.
4. **Консультація:** якщо останній консультаційний запис посилається на візит, якого **немає (404)** — очищаються `consultationBookingDate`, `consultationMasterName`, `consultationMasterId`, `consultationAttended` тощо.
5. **Платний запис:** аналогічно — якщо візит платного запису 404, очищається платний блок.
6. Якщо консультаційних записів взагалі немає, а в клієнта були заповнені поля консультації — вони також очищаються.
7. **Дублікати:** після оновлення основного клієнта всі інші записи з тим самим `instagramUsername` (case-insensitive) оновлюються тими самими null-полями, щоб у таблиці зникли консультація/запис у всіх рядках одного й того ж клієнта.

Зміни зберігаються через **Prisma** (`prisma.directClient.update`), потім викликається `saveDirectClient` для логування.

### Відповідь

- `ok: true`, `clientId`, **`altegioClientId`**, `instagramUsername`, `clearedConsultation`, `clearedPaid`, `duplicatesUpdated`, `message`, `afterUpdate` (поточні значення полів після оновлення).

Фронт використовує **altegioClientId** і **clientId** (і при потребі instagramUsername) для збереження факту «щойно очистили», щоб наступний refetch не перезаписав очищені поля старими даними.

---

## 4. Фронт: оновлення таблиці та захист від повернення даних

### 4.1. Миттєве оновлення після очищення

- Після успішної відповіді API викликається **`handleClearVisitsSuccess(data)`**.
- У стейті `clients` оновлюються всі рядки, що відповідають клієнту:
  - за **altegioClientId** (основний варіант);
  - за **clientId** (внутрішній id);
  - за **instagramUsername** (дублікати, коли у рядка може не бути altegioClientId).
- У цих рядках поля консультації/платного запису встановлюються в `undefined`, тому дата й майстер у колонках «Консультація»/«Запис» одразу зникають.

Після очищення **не** викликається `loadData()` / `loadClients()` — щоб не підставляти застарілий список з API.

### 4.2. Чому консультація «поверталася»

- Кожні **30 секунд** спрацьовує авто-оновлення і викликає **`loadClients()`**.
- Якщо просто підставити в таблицю відповідь API (`setClients(data.clients)`), то при застарілому або закешованому відповіді старі значення консультації/запису знову з’являться в UI.
- Після **перезавантаження сторінки** ref (див. нижче) обнуляється, тож захист працює лише до наступного refetch у межах однієї сесії; далі все залежить від того, що реально повертає API з БД.

### 4.3. Захист: ref «нещодавно очищених» і merge при refetch

- **Ref:** `recentlyClearedVisitsRef` — це `Map`, де зберігаються клієнти, для яких щойно очистили консультацію або платний запис. Ключі записуються в **трьох** варіантах, щоб покрити всі рядки в таблиці:
  - **altegioClientId** (string) — основний, стабільний ідентифікатор;
  - **clientId** — наш внутрішній id;
  - **instagramUsername** (lowercase) — для дублікатів і клієнтів без altegioClientId.
- Значення: `{ consultationClearedAt?: number, paidClearedAt?: number }` (timestamp).
- **Тривалість захисту:** **1 година** (`CLEARED_VISITS_GRACE_MS`). Протягом цього часу будь-який наступний виклик `loadClients()` не просто підставляє список з API, а **зливає** його з цим ref.

### 4.4. Merge у `loadClients()`

Перед `setClients(filteredClients)`:

1. Для кожного клієнта `c` з відповіді API шукається запис у ref за ключами (у такому порядку):
   - `String(c.altegioClientId)`, якщо є;
   - `c.id`;
   - `(c.instagramUsername ?? '').trim().toLowerCase()`, якщо є.
2. Якщо запис знайдено і **не минуло 1 години** з моменту очищення (`consultationClearedAt` або `paidClearedAt`):
   - для консультації: в об’єкті клієнта примусово встановлюються `consultationBookingDate`, `consultationMasterName` тощо в `undefined`;
   - для платного запису: аналогічно очищуються відповідні поля.
3. У таблицю передається вже **змержений** список; навіть якщо API повернув старі значення, вони не відображаються.

Таким чином механізм опирається на **altegioClientId** (і при потребі на **clientId** та **instagramUsername**), щоб консультація/запис не «повертались» після авто-оновлення або зміни фільтрів протягом **1 години** після очищення.

### 4.5. Пауза авто-оновлення на 2 хвилини

- Після успішного очищення встановлюється **`pauseAutoRefreshUntilRef`** = поточний час + 2 хвилини.
- У **setInterval** (запит кожні 30 с) на початку кожного виклику перевіряється: якщо `Date.now() < pauseAutoRefreshUntilRef`, то **`loadClients()` не викликається** — інтервал пропускається.
- Таким чином протягом **2 хвилин** після очищення таблиця взагалі не оновлюється з API; показуються лише дані, встановлені в `handleClearVisitsSuccess`. Після 2 хвилин авто-оновлення відновлюється, а захист від перезапису продовжує працювати через merge ще **58 хвилин** (разом 1 година).

### 4.6. Позначка «Видалено в Altegio» (consultationDeletedInAltegio)

- У БД зберігається поле **`consultationDeletedInAltegio`** (boolean). Коли консультацію очищають через відсутність візиту в Altegio (404), це поле встановлюється в **true**.
- **Вебхуки Altegio** та **sync/cron**, які знову встановлюють дату консультації або майстра, перевіряють цей прапорець: якщо він **true**, таке оновлення **пропускається** (консультація не перезаписується). Таким чином стан «видалено» зберігається, поки в Altegio не з’явиться **новий** запис на консультацію.
- Коли з будь-якого джерела (вебхук, sync-visit-history, cron) знову встановлюють **не-null** дату/майстра консультації, одночасно виставляють **`consultationDeletedInAltegio = false`**.
- У таблиці Direct у колонці «Консультація» для клієнтів без дати, але з **consultationDeletedInAltegio = true**, показується текст **«Видалено в Altegio»** (сірий, курсив) замість порожньої комірки.

---

## 5. Файли

| Що | Файл |
|----|------|
| API очищення | `web/app/api/admin/direct/clear-deleted-visits-for-client/route.ts` |
| Кнопка та виклик API | `web/app/admin/direct/_components/AdminToolsModal.tsx` |
| Обробка успіху, ref, merge, пауза авто-refresh | `web/app/admin/direct/page.tsx` (`handleClearVisitsSuccess`, `recentlyClearedVisitsRef`, `pauseAutoRefreshUntilRef`, merge у `loadClients`) |

---

## 6. Якщо консультація все одно з’являється знову

- Переконайтесь, що вводите саме **Altegio Client ID** і що в клієнта він заповнений (в картці клієнта в Direct).
- **Перші 2 хвилини** після очищення авто-refresh взагалі не викликає `loadClients()` — таблиця не має перезаписатись. Якщо консультація з’являється вже в цей період — можливо спрацював refetch при зміні фільтрів/сорту (окремий useEffect); перевірити merge за ключами altegioClientId / id / username.
- Якщо проблема після **перезавантаження сторінки** — ref порожній; тоді дані беруться тільки з API. Перевірте в БД, чи дійсно в запису `consultationBookingDate` та пов’язані поля = null після очищення.
- Якщо проблема через **більше ніж 1 годину** після очищення — захист по ref вже не застосовується; має повертатися те, що в БД. Якщо в БД null, а в UI все одно показується дата — можливе кешування. Якщо в БД знову з’явились дані консультації — їх щось записало (вебхук Altegio, sync, cron); тоді потрібно або не очищати ці поля в цих сценаріях, або повторно викликати «Очистити видалені візити».
