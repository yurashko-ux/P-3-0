# Чому сторінка тестів не бачить V1/V2 кампаній

Під час виконання кроку «Пошук кампанії» ми покладаємося на утиліту `kvRead.listCampaigns`. Вона спочатку намагається читати індекси та елементи через REST API Vercel KV (`KV_REST_API_URL` + токени; або `UPSTASH_REDIS_REST_URL` / `UPSTASH_REDIS_REST_TOKEN`, якщо працюємо напряму з Upstash). Якщо ж цих токенів немає, то відбувається перехід на локальний биндинг `@vercel/kv`. Коли обидва канали недоступні або налаштовані не для того середовища, метод повертає порожній масив, і ми просто не отримуємо самі об'єкти кампаній.

Через це V1/V2 не «зчитуються» — до нас не доходить жоден запис кампанії, отже, немає з чого витягти правила. Це не проблема формату самих правил: список `cmp:ids` та відповідні `cmp:item:*` зчитуються коректно, щойно доступ до KV працює. Поки з'єднання з KV немає, будь-які пошуки V1/V2 будуть безрезультатними.

Щоб пересвідчитись, достатньо в тому ж середовищі виконати запит на `kvRead.getRaw('cmp:item:<ID>')` або `kvRead.lrange('cmp:ids')`. Якщо відповідь порожня — значить, проблема у відсутності доступу до KV, а не в логіці обробки V1/V2.

> **Швидка перевірка прямо зараз.** Якщо потрібно просто скопіювати готову команду з наданими реквізитами (`UPSTASH_REDIS_REST_URL="https://hot-louse-21041.upstash.io"`, `UPSTASH_REDIS_REST_TOKEN="AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE"`), виконайте **саме цю** команду без будь-яких додаткових підстановок або змін:
>
> ```bash
> curl -i \
>   -H "Authorization: Bearer AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE" \
>   "https://hot-louse-21041.upstash.io/ping"
> ```
>
> Статус `HTTP/1.1 200 OK` та тіло `{"result":"PONG"}` підтверджують, що токен чинний.

> ⚠️ Наявність змінних `KV_REST_API_URL` і `KV_REST_API_TOKEN` не гарантує доступу: токен може бути простроченим, без потрібних прав або прив'язаним до іншого середовища/простору. У такій ситуації `fetch` повертає 401/403 (або порожній JSON), і клієнт так само бачить «порожні» кампанії.

## Як оновити або перевипустити REST-токен Vercel KV

1. Відкрийте у Vercel проєкт, у якому створено KV. Перейдіть у розділ **Storage → KV Databases**.
2. Оберіть потрібну базу та натисніть **View Details** → вкладка **API Tokens**.
3. Натисніть **Create Token** (або **Regenerate**, якщо токен був скомпрометований). Вкажіть потрібні права: для читання кампаній достатньо `read`, але для синку також може знадобитись `write`.
4. Скопіюйте значення `REST API URL` і `REST API Token`. Переконайтесь, що токен належить тому самому середовищу (Production/Staging), з якого працює застосунок.
5. Оновіть змінні середовища `KV_REST_API_URL` і `KV_REST_API_TOKEN` (або `UPSTASH_REDIS_REST_URL` / `UPSTASH_REDIS_REST_TOKEN`, якщо працюєте напряму з Upstash) у Vercel або у локальному `.env`. Після зміни на проді не забудьте перезапустити деплой чи зробити `vercel redeploy`, щоб інстанси підхопили нові значення.
6. Перевірте з'єднання: найпростіше зробити `curl $KV_REST_API_URL/ping` із заголовком `Authorization: Bearer <TOKEN>` або використати вбудовану сторінку тестів. Якщо отримуєте статус 200 і тіло `"PONG"` — токен чинний.

## Команди для швидкої перевірки токена

> Якщо отримали креденшіали безпосередньо з Upstash, найпростіше експортувати їх у змінні, які очікує документація: `export KV_REST_API_URL="$UPSTASH_REDIS_REST_URL"` та `export KV_REST_API_TOKEN="$UPSTASH_REDIS_REST_TOKEN"`.
> У всіх прикладах вважаємо, що змінні `KV_REST_API_URL` та `KV_REST_API_TOKEN` (або `UPSTASH_REDIS_REST_URL` / `UPSTASH_REDIS_REST_TOKEN`) вже експортовані в середовище (наприклад, через `source .env.local`).

### Найшвидший тест одним запитом

1. У терміналі підставте власні значення та виконайте найпростіший `PING` (рядки з `\` означають продовження):

   ```bash
   curl -i -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/ping"
   ```

2. Успішна відповідь має статус `HTTP/1.1 200 OK` і тіло `"PONG"`. Це означає, що REST-токен чинний і доступ до KV є.
3. Якщо бачите `401 Unauthorized` або `403 Forbidden`, токен або URL неправильні (прострочені, з іншого середовища чи без прав). Перевипустіть креденшіали за інструкцією вище й повторіть запит.
4. Відповідь `400 Bad Request` із текстом на кшталт `ERR wrong number of arguments` означає, що сервер не розпізнав шлях як підтримувану команду (наприклад, якщо додати зайві параметри). Перевірте, що ви викликаєте саме `/ping` без додаткових аргументів, або використайте команду `SCAN` нижче для розширеної перевірки.

### Що означає відповідь `{"result":"PONG"}`

Успішний виклик `curl .../ping` поверне приблизно таку відповідь:

```
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
...
{"result":"PONG"}
```

* Статус 200 і тіло `{"result":"PONG"}` підтверджують, що токен чинний, URL вказує на правильну базу, а сервер приймає запити.
* Якщо бачите саме таку відповідь, можна повертатися до адмінського тестера ManyChat → KeyCRM: пошук кампаній має працювати (за умови, що KV містить актуальні записи `cmp:ids`/`cmp:item:*`).
* Якщо ж у наступних кроках кампанія не знаходиться, шукайте причину вже у самих даних (наприклад, порожній індекс або невідповідність V1/V2), а не в доступі до KV.

> **Порада.** Якщо вводите значення токена/URL вручну, не додавайте перед ними знак `$`. Наприклад, коректно так:
>
> ```bash
> curl -i -H "Authorization: Bearer AVIxAAI..." \
>   "https://hot-louse-21041.upstash.io/ping"
> ```
>
> У команді вище підставлено самі значення, тому `$` не потрібен. Знак `$` використовуйте лише тоді, коли читаєте значення зі змінної середовища (`$KV_REST_API_TOKEN`).

> **Готова команда з наданими токенами.** Якщо потрібно просто скопіювати та виконати запит з поточними Upstash реквізитами (`UPSTASH_REDIS_REST_URL="https://hot-louse-21041.upstash.io"`, `UPSTASH_REDIS_REST_TOKEN="AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE"`), використайте готову команду:
>
> ```bash
> curl -i \
>   -H "Authorization: Bearer AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE" \
>   "https://hot-louse-21041.upstash.io/ping"
> ```
>
> Вона поверне `HTTP/1.1 200 OK` і тіло `{"result":"PONG"}`, якщо токен чинний і доступ до бази працює.
> Наприклад, валідний виклик видає саме таку відповідь:
>
> ```
> HTTP/1.1 200 OK
> Access-Control-Allow-Credentials: true
> Content-Length: 17
> Content-Type: application/json; charset=utf-8
> Date: Mon, 06 Oct 2025 22:41:21 GMT
> Server: Upstash Redis Database (1.14.4)
> Upstash-Sync-Token: 0
>
> {"result":"PONG"}
> ```
>
> Якщо бачите саме таку відповідь, REST-канал працює й можна переходити до читання ключів `cmp:ids` / `cmp:item:*`.

> **Наступний крок після `PONG`.** Щоб переконатися, що в базі дійсно є кампанії, одразу після успішного ping виконайте команду `LRANGE` через HTTP-пайплайн. Такий варіант не залежить від форматування URL і працює навіть тоді, коли варіант із `/lrange/...` повертає `400 Bad Request`:

```bash
curl -fsS -X POST \
  -H "Authorization: Bearer AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE" \
  -H "Content-Type: application/json" \
  -d '["LRANGE","cmp:ids",0,-1]' \
  "https://hot-louse-21041.upstash.io"
```

> Зверніть увагу: значення меж `0` та `-1` потрібно передавати як числа. Якщо загорнути їх у лапки, Upstash відповість `400 Bad Request` з помилкою `ERR value is not an integer`, і список кампаній не повернеться.

> Помилка `ERR wrong number of arguments for 'keys' command` у попередніх спробах означала, що сервер отримував запит на іншу команду (наприклад, `KEYS`). POST-варіант вище напряму відправляє Redis-команду та усуває залежність від URL-енкодингу `:` або `*`.

Якщо потрібно одразу відформатувати JSON, додайте будь-який зручний преттір:

```bash
curl -fsS -X POST \
  -H "Authorization: Bearer AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE" \
  -H "Content-Type: application/json" \
  -d '["LRANGE","cmp:ids",0,-1]' \
  "https://hot-louse-21041.upstash.io" | python3 -m json.tool
```

Якщо ні `python3`, ні `jq` не встановлені, можна залишити лише `curl …` або використати будь-яку іншу утиліту для форматування JSON (наприклад, `node -e 'process.stdin.on("data", d => console.log(JSON.stringify(JSON.parse(d.toString()), null, 2)))'`).
>
> Якщо відповідь — масив із ідентифікаторами (наприклад, `["cmp:item:123","cmp:item:456"]`), значить, дані кампаній присутні й `kvRead.listCampaigns` зможе їх побачити. Статус 200 із `[]` означає, що доступ є, але індекс поки порожній; у такому випадку перевірте, що процес синхронізації KeyCRM → KV відпрацьовує коректно.
>
> **Потрібна готова команда без додаткових утиліт.** Нижче наведено повністю розписаний POST-запит саме з вашими Upstash реквізитами; можна просто скопіювати та вставити його в термінал. Команда поверне сирий JSON-масив індексів кампаній (без `jq` чи `python`):

```bash
curl -fsS -X POST \
  -H "Authorization: Bearer AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE" \
  -H "Content-Type: application/json" \
  -d '["LRANGE","cmp:ids",0,-1]' \
  "https://hot-louse-21041.upstash.io"
```
>
> Якщо відповідь виглядає як `[]`, індекс порожній; якщо ж бачите елементи на кшталт `"cmp:item:123"`, значить, кампанії присутні й можна перейти до читання конкретних записів.
>
> Далі можна вибрати один з ідентифікаторів та перечитати саму кампанію (ключ `cmp:item:<ID>` зберігається як JSON-рядок):
>
```bash
curl -fsS -X POST \
  -H "Authorization: Bearer AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE" \
  -H "Content-Type: application/json" \
  -d '["GET","cmp:item:123"]' \
  "https://hot-louse-21041.upstash.io" | jq .
```
>
> > **Примітка.** На деяких macOS-консолях `jq` відсутнє за замовчуванням. Його можна встановити через `brew install jq` або замінити на `python -m json.tool`, як показано вище.
>
> Підставте потрібний ідентифікатор замість `123`, щоб перевірити, чи містить кампанія очікувані V1/V2.
>
> **Повністю готова команда для читання кампанії.** Щоб не підставляти нічого вручну, ось запит із вашими реквізитами, який одразу
> зчитає кампанію `cmp:item:123` (замініть 123, якщо потрібен інший ID):
>
> ```bash
> curl -fsS -X POST \
>   -H "Authorization: Bearer AVIxAAIncDEwMzc2NTgwYzgzOTc0NzUzYjIxMzY3Y2U2NzdkNjY1MXAxMjEwNDE" \
>   -H "Content-Type: application/json" \
>   -d '["GET","cmp:item:123"]' \
>   "https://hot-louse-21041.upstash.io"
> ```
>
> Відповідь повернеться у вигляді JSON-рядка; щоб зробити її читабельною, можна додати `| python3 -m json.tool` або вставити
> результат у будь-який онлайн форматер.

### Розширена перевірка

1. Перевірити, що токен приймається сервером і повертає відповідь на `PING`:

   ```bash
   curl -fsS \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/ping"
   ```

   *Як інтерпретувати:*
   - HTTP 200 + рядок `"PONG"` → токен чинний і має доступ `read`.
   - HTTP 401/403 → токен прострочений, відкликаний або належить іншому середовищу.

2. Запитати конкретний ключ (наприклад, індекс кампаній `cmp:ids`) і впевнитися, що дані читаються. Це Redis List, тому замість `GET` потрібно викликати `LRANGE`:

   ```bash
   curl -fsS \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/lrange/cmp%3Aids/0/-1" | jq .
   ```

   Якщо побачите згадану вище помилку про `keys`, переконайтеся, що в шляху немає символу `*` без URL-кодування. У крайньому разі можна обійти індекс через `SCAN`:

   ```bash
   curl -fsS \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/scan/0/cmp%3A%2A/5" | jq .
   ```

   Команда поверне масив на кшталт `["cmp:ids","cmp:item:123", ...]`, звідки можна взяти потрібний ключ.

   *Як інтерпретувати:*
   - JSON-масив зі значеннями → REST-шлях повертає фактичні дані індексу.
   - Відповідь `[]` при статусі 200 → ключ існує, але індекс порожній; перевірте, чи кампанії взагалі записані.
   - Помилка 404 → ключ не знайдено, можливий інший namespace/простір.

3. Якщо потрібно обмежити кількість повернених ключів, скористайтесь командою `SCAN`, яка приймає курсор, шаблон і ліміт:

   ```bash
   curl -fsS \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/scan/0/%2A/5" | jq .
   ```

   У відповіді перший елемент — новий курсор, другий — масив ключів (не більше 5).

4. За потреби перевірити права на запис (опційно, якщо токен повинен дозволяти синхронізацію):

   ```bash
   curl -fsS -X POST \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     -H "Content-Type: application/json" \
     "$KV_REST_API_URL/set" \
     -d '{"key":"kv-token-selftest","value":"ok","ex":60}'
   ```

   - HTTP 200 → токен має `write`-дозвіл.
   - HTTP 403 → токен лише для читання; для синку потрібен ширший доступ або інший токен.

   Після перевірки можна видалити тимчасовий ключ:

   ```bash
   curl -fsS -X POST \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/del" \
     -d '{"key":"kv-token-selftest"}'
   ```

## Як знайти кампанію за значенням V1/V2 (без знання ID)

Іноді потрібно не просто підтягнути кампанію за конкретним `cmp:item:<ID>`, а відшукати її за маршрутом `v1` чи `v2`. Для цього тепер достатньо звернутися до REST-ендпойнта самого застосунку: `/api/campaigns` уміє фільтрувати кампанії за нормалізованим значенням правил.

1. Запустіть локальний девсервер (`npm run dev` у директорії `web`) **або** використайте бойовий/стейджинг-домен Vercel.
2. Зробіть запит із потрібними параметрами:
   * `value` (`q`, `rule` або `needle`) — шукане значення, наприклад `1` чи `promo-2024` (регістр неважливий).
   * `slot` — опційно, щоб обмежити пошук лише `v1` або `v2`. За замовчуванням перевіряються обидва.
   * `match` — опційно: `equals` для точного збігу або `contains` (за замовчуванням) для пошуку «містить».
   * `active=true` — опційно, аби виключити неактивні кампанії.

Наприклад, щоб знайти всі кампанії, у яких `v1` дорівнює `1`, запустіть (замініть `http://localhost:3000` на домен вашого деплою, якщо потрібно):

```bash
curl -fsS "http://localhost:3000/api/campaigns?value=1&slot=v1&match=equals" | jq '.[].name'
```

У відповіді повернеться масив кампаній із додатковим полем `ruleMatches`, де видно, який слот спрацював і яке значення знайшло збіг. Заголовки `x-total-campaigns`, `x-total-returned`, `x-rule-needle`, `x-rule-mode` та `x-rule-slots` підкажуть, скільки всього записів у KV і як саме було застосовано фільтр.

> **Швидкий старт із продакшеном.** Якщо застосунок уже задеплоєно на Vercel, достатньо підставити робочий домен:
> ```bash
> curl -fsS "https://your-app.vercel.app/api/campaigns?value=1&slot=v1&match=equals"
> ```
> Ви отримаєте ті самі дані, що й локально, лише з реальними кампаніями.

## Як підключити прямий биндинг `@vercel/kv`

1. У Vercel відкрийте сторінку деплою проєкту, перейдіть у **Settings → Environment Variables** та додайте системну змінну `KV_REST_API_URL`/`TOKEN` (для fallback) і параметр `KV_URL`/`KV_REST_API_TOKEN` (Vercel додасть їх автоматично під час биндингу).
2. У файлі `vercel.json` або в налаштуваннях проєкту додайте ресурс `kv`: `"kv": ["<ім'я-бази>"]`. Після збереження Vercel видасть креденшіали `KV_URL`, `KV_REST_API_URL`, `KV_REST_API_TOKEN` і `KV_REST_API_READ_ONLY_TOKEN`.
3. Для локальної розробки встановіть CLI Vercel і виконайте `vercel link`, а потім `vercel env pull .env.local`, щоби отримати всі секрети, включно з KV.
4. У середовищах, де запускається Next.js, переконайтесь, що пакет `@vercel/kv` доступний (він автоматично працює на Vercel). Якщо ви запускаєте сервер поза Vercel, скористайтеся [Upstash Redis credentials](https://vercel.com/docs/storage/vercel-kv/quickstart) і передайте їх у змінні `KV_URL`, `KV_REST_API_URL`, `KV_REST_API_TOKEN`.
5. Після підключення перевірте, що `process.env.KV_URL` не порожній. Тоді `kvRead` зможе використовувати прямий биндинг без REST-запитів.

## Режим офлайн-снепшоту

Коли доступу до Upstash/Vercel KV немає (локальна розробка без інтернету тощо), можна підкласти дамп кампаній через один із параметрів середовища:

- `KV_CAMPAIGNS_SNAPSHOT_JSON` — рядок із JSON-масивом кампаній або об'єктом `{ index, items }`.
- `KV_CAMPAIGNS_SNAPSHOT_FILE` — шлях до файлу з таким самим JSON.

`kvRead.listCampaigns` автоматично підхопить ці дані, додасть їх до списку індексів і поверне ті самі об'єкти, ніби вони прийшли з KV. Це дозволяє тестеру V1/V2 і вебхукам ManyChat працювати навіть у середовищах без мережі. Щойно з'єднання з KV доступне, фактичні дані мають пріоритет над снепшотом.
