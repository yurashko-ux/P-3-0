# Чому сторінка тестів не бачить V1/V2 кампаній

Під час виконання кроку «Пошук кампанії» ми покладаємося на утиліту `kvRead.listCampaigns`. Вона спочатку намагається читати індекси та елементи через REST API Vercel KV (`KV_REST_API_URL` + токени). Якщо ж цих токенів немає, то відбувається перехід на локальний биндинг `@vercel/kv`. Коли обидва канали недоступні або налаштовані не для того середовища, метод повертає порожній масив, і ми просто не отримуємо самі об'єкти кампаній.

Через це V1/V2 не «зчитуються» — до нас не доходить жоден запис кампанії, отже, немає з чого витягти правила. Це не проблема формату самих правил: список `cmp:ids` та відповідні `cmp:item:*` зчитуються коректно, щойно доступ до KV працює. Поки з'єднання з KV немає, будь-які пошуки V1/V2 будуть безрезультатними.

Щоб пересвідчитись, достатньо в тому ж середовищі виконати запит на `kvRead.getRaw('cmp:item:<ID>')` або `kvRead.lrange('cmp:ids')`. Якщо відповідь порожня — значить, проблема у відсутності доступу до KV, а не в логіці обробки V1/V2.

> ⚠️ Наявність змінних `KV_REST_API_URL` і `KV_REST_API_TOKEN` не гарантує доступу: токен може бути простроченим, без потрібних прав або прив'язаним до іншого середовища/простору. У такій ситуації `fetch` повертає 401/403 (або порожній JSON), і клієнт так само бачить «порожні» кампанії.

## Як оновити або перевипустити REST-токен Vercel KV

1. Відкрийте у Vercel проєкт, у якому створено KV. Перейдіть у розділ **Storage → KV Databases**.
2. Оберіть потрібну базу та натисніть **View Details** → вкладка **API Tokens**.
3. Натисніть **Create Token** (або **Regenerate**, якщо токен був скомпрометований). Вкажіть потрібні права: для читання кампаній достатньо `read`, але для синку також може знадобитись `write`.
4. Скопіюйте значення `REST API URL` і `REST API Token`. Переконайтесь, що токен належить тому самому середовищу (Production/Staging), з якого працює застосунок.
5. Оновіть змінні середовища `KV_REST_API_URL` і `KV_REST_API_TOKEN` у Vercel або у локальному `.env`. Після зміни на проді не забудьте перезапустити деплой чи зробити `vercel redeploy`, щоб інстанси підхопили нові значення.
6. Перевірте з'єднання: найпростіше зробити `curl $KV_REST_API_URL/keys` з заголовком `Authorization: Bearer <TOKEN>` або використати вбудовану сторінку тестів. Якщо відповідає список ключів без помилок 401/403 — токен чинний.

## Команди для швидкої перевірки токена

> У всіх прикладах вважаємо, що змінні `KV_REST_API_URL` та `KV_REST_API_TOKEN` вже експортовані в середовище (наприклад, через `source .env.local`).

1. Перевірити, що токен приймається сервером і повертає список ключів:

   ```bash
   curl -fsS \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/keys?limit=5" | jq .
   ```

   *Як інтерпретувати:*
   - HTTP 200 + JSON зі списком ключів → токен чинний і має доступ `read`.
   - HTTP 401/403 → токен прострочений, відкликаний або належить іншому середовищу.

2. Запитати конкретний ключ (наприклад, індекс кампаній `cmp:ids`) і впевнитися, що дані читаються:

   ```bash
   curl -fsS \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/get/cmp%3Aids" | jq .
   ```

   *Як інтерпретувати:*
   - JSON зі значенням ключа → REST-шлях повертає фактичні дані.
   - Відповідь `null` при статусі 200 → ключ існує, але порожній; перевірте, чи кампании взагалі записані.
   - Помилка 404 → ключ не знайдено, можливий інший namespace/простір.

3. За потреби перевірити права на запис (опційно, якщо токен повинен дозволяти синхронізацію):

   ```bash
   curl -fsS -X POST \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     -H "Content-Type: application/json" \
     "$KV_REST_API_URL/set" \
     -d '{"key":"kv-token-selftest","value":"ok","ex":60}'
   ```

   - HTTP 200 → токен має `write`-дозвіл.
   - HTTP 403 → токен лише для читання; для синку потрібен ширший доступ або інший токен.

   Після перевірки можна видалити тимчасовий ключ:

   ```bash
   curl -fsS -X POST \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/del" \
     -d '{"key":"kv-token-selftest"}'
   ```

## Як підключити прямий биндинг `@vercel/kv`

1. У Vercel відкрийте сторінку деплою проєкту, перейдіть у **Settings → Environment Variables** та додайте системну змінну `KV_REST_API_URL`/`TOKEN` (для fallback) і параметр `KV_URL`/`KV_REST_API_TOKEN` (Vercel додасть їх автоматично під час биндингу).
2. У файлі `vercel.json` або в налаштуваннях проєкту додайте ресурс `kv`: `"kv": ["<ім'я-бази>"]`. Після збереження Vercel видасть креденшіали `KV_URL`, `KV_REST_API_URL`, `KV_REST_API_TOKEN` і `KV_REST_API_READ_ONLY_TOKEN`.
3. Для локальної розробки встановіть CLI Vercel і виконайте `vercel link`, а потім `vercel env pull .env.local`, щоби отримати всі секрети, включно з KV.
4. У середовищах, де запускається Next.js, переконайтесь, що пакет `@vercel/kv` доступний (він автоматично працює на Vercel). Якщо ви запускаєте сервер поза Vercel, скористайтеся [Upstash Redis credentials](https://vercel.com/docs/storage/vercel-kv/quickstart) і передайте їх у змінні `KV_URL`, `KV_REST_API_URL`, `KV_REST_API_TOKEN`.
5. Після підключення перевірте, що `process.env.KV_URL` не порожній. Тоді `kvRead` зможе використовувати прямий биндинг без REST-запитів.

## Режим офлайн-снепшоту

Коли доступу до Upstash/Vercel KV немає (локальна розробка без інтернету тощо), можна підкласти дамп кампаній через один із параметрів середовища:

- `KV_CAMPAIGNS_SNAPSHOT_JSON` — рядок із JSON-масивом кампаній або об'єктом `{ index, items }`.
- `KV_CAMPAIGNS_SNAPSHOT_FILE` — шлях до файлу з таким самим JSON.

`kvRead.listCampaigns` автоматично підхопить ці дані, додасть їх до списку індексів і поверне ті самі об'єкти, ніби вони прийшли з KV. Це дозволяє тестеру V1/V2 і вебхукам ManyChat працювати навіть у середовищах без мережі. Щойно з'єднання з KV доступне, фактичні дані мають пріоритет над снепшотом.
