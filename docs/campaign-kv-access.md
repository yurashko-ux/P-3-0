# Чому сторінка тестів не бачить V1/V2 кампаній

Під час виконання кроку «Пошук кампанії» ми покладаємося на утиліту `kvRead.listCampaigns`. Вона спочатку намагається читати індекси та елементи через REST API Vercel KV (`KV_REST_API_URL` + токени; або `UPSTASH_REDIS_REST_URL` / `UPSTASH_REDIS_REST_TOKEN`, якщо працюємо напряму з Upstash). Якщо ж цих токенів немає, то відбувається перехід на локальний биндинг `@vercel/kv`. Коли обидва канали недоступні або налаштовані не для того середовища, метод повертає порожній масив, і ми просто не отримуємо самі об'єкти кампаній.

Через це V1/V2 не «зчитуються» — до нас не доходить жоден запис кампанії, отже, немає з чого витягти правила. Це не проблема формату самих правил: список `cmp:ids` та відповідні `cmp:item:*` зчитуються коректно, щойно доступ до KV працює. Поки з'єднання з KV немає, будь-які пошуки V1/V2 будуть безрезультатними.

Щоб пересвідчитись, достатньо в тому ж середовищі виконати запит на `kvRead.getRaw('cmp:item:<ID>')` або `kvRead.lrange('cmp:ids')`. Якщо відповідь порожня — значить, проблема у відсутності доступу до KV, а не в логіці обробки V1/V2.

> ⚠️ Наявність змінних `KV_REST_API_URL` і `KV_REST_API_TOKEN` не гарантує доступу: токен може бути простроченим, без потрібних прав або прив'язаним до іншого середовища/простору. У такій ситуації `fetch` повертає 401/403 (або порожній JSON), і клієнт так само бачить «порожні» кампанії.

## Як оновити або перевипустити REST-токен Vercel KV

1. Відкрийте у Vercel проєкт, у якому створено KV. Перейдіть у розділ **Storage → KV Databases**.
2. Оберіть потрібну базу та натисніть **View Details** → вкладка **API Tokens**.
3. Натисніть **Create Token** (або **Regenerate**, якщо токен був скомпрометований). Вкажіть потрібні права: для читання кампаній достатньо `read`, але для синку також може знадобитись `write`.
4. Скопіюйте значення `REST API URL` і `REST API Token`. Переконайтесь, що токен належить тому самому середовищу (Production/Staging), з якого працює застосунок.
5. Оновіть змінні середовища `KV_REST_API_URL` і `KV_REST_API_TOKEN` (або `UPSTASH_REDIS_REST_URL` / `UPSTASH_REDIS_REST_TOKEN`, якщо працюєте напряму з Upstash) у Vercel або у локальному `.env`. Після зміни на проді не забудьте перезапустити деплой чи зробити `vercel redeploy`, щоб інстанси підхопили нові значення.
6. Перевірте з'єднання: найпростіше зробити `curl $KV_REST_API_URL/keys` з заголовком `Authorization: Bearer <TOKEN>` або використати вбудовану сторінку тестів. Якщо відповідає список ключів без помилок 401/403 — токен чинний.

## Команди для швидкої перевірки токена

> Якщо отримали креденшіали безпосередньо з Upstash, найпростіше експортувати їх у змінні, які очікує документація: `export KV_REST_API_URL="$UPSTASH_REDIS_REST_URL"` та `export KV_REST_API_TOKEN="$UPSTASH_REDIS_REST_TOKEN"`.
> У всіх прикладах вважаємо, що змінні `KV_REST_API_URL` та `KV_REST_API_TOKEN` (або `UPSTASH_REDIS_REST_URL` / `UPSTASH_REDIS_REST_TOKEN`) вже експортовані в середовище (наприклад, через `source .env.local`).

### Найшвидший тест одним запитом

1. У терміналі підставте власні значення та виконайте команду (рядки з `\` означають продовження):

   ```bash
   curl -i -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/keys/*?limit=1"
   ```

2. Успішна відповідь має статус `HTTP/1.1 200 OK` і JSON зі списком ключів (навіть якщо він пустий). Це означає, що REST-токен чинний і доступ до KV є.
3. Якщо бачите `401 Unauthorized` або `403 Forbidden`, токен або URL неправильні (прострочені, з іншого середовища чи без прав). Перевипустіть креденшіали за інструкцією вище й повторіть запит.
4. Відповідь `400 Bad Request` з текстом `ERR wrong number of arguments for 'keys' command` сигналізує, що запит викликав KEYS без шаблону (наприклад, `/keys?limit=1` замість `/keys/*?limit=1`). У такому випадку сам токен прийнято, тож просто повторіть запит із доданим шаблоном `*`.

> **Порада.** Якщо вводите значення токена/URL вручну, не додавайте перед ними знак `$`. Наприклад, коректно так:
>
> ```bash
> curl -i -H "Authorization: Bearer AVIxAAI..." \
>   "https://hot-louse-21041.upstash.io/keys/*?limit=1"
> ```
>
> У команді вище підставлено самі значення, тому `$` не потрібен. Знак `$` використовуйте лише тоді, коли читаєте значення зі змінної середовища (`$KV_REST_API_TOKEN`).

### Розширена перевірка

1. Перевірити, що токен приймається сервером і повертає список ключів:

   ```bash
   curl -fsS \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/keys/*?limit=5" | jq .
   ```

   *Як інтерпретувати:*
   - HTTP 200 + JSON зі списком ключів → токен чинний і має доступ `read`.
   - HTTP 401/403 → токен прострочений, відкликаний або належить іншому середовищу.

2. Запитати конкретний ключ (наприклад, індекс кампаній `cmp:ids`) і впевнитися, що дані читаються:

   ```bash
   curl -fsS \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/get/cmp%3Aids" | jq .
   ```

   *Як інтерпретувати:*
   - JSON зі значенням ключа → REST-шлях повертає фактичні дані.
   - Відповідь `null` при статусі 200 → ключ існує, але порожній; перевірте, чи кампании взагалі записані.
   - Помилка 404 → ключ не знайдено, можливий інший namespace/простір.

3. За потреби перевірити права на запис (опційно, якщо токен повинен дозволяти синхронізацію):

   ```bash
   curl -fsS -X POST \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     -H "Content-Type: application/json" \
     "$KV_REST_API_URL/set" \
     -d '{"key":"kv-token-selftest","value":"ok","ex":60}'
   ```

   - HTTP 200 → токен має `write`-дозвіл.
   - HTTP 403 → токен лише для читання; для синку потрібен ширший доступ або інший токен.

   Після перевірки можна видалити тимчасовий ключ:

   ```bash
   curl -fsS -X POST \
     -H "Authorization: Bearer $KV_REST_API_TOKEN" \
     "$KV_REST_API_URL/del" \
     -d '{"key":"kv-token-selftest"}'
   ```

## Як підключити прямий биндинг `@vercel/kv`

1. У Vercel відкрийте сторінку деплою проєкту, перейдіть у **Settings → Environment Variables** та додайте системну змінну `KV_REST_API_URL`/`TOKEN` (для fallback) і параметр `KV_URL`/`KV_REST_API_TOKEN` (Vercel додасть їх автоматично під час биндингу).
2. У файлі `vercel.json` або в налаштуваннях проєкту додайте ресурс `kv`: `"kv": ["<ім'я-бази>"]`. Після збереження Vercel видасть креденшіали `KV_URL`, `KV_REST_API_URL`, `KV_REST_API_TOKEN` і `KV_REST_API_READ_ONLY_TOKEN`.
3. Для локальної розробки встановіть CLI Vercel і виконайте `vercel link`, а потім `vercel env pull .env.local`, щоби отримати всі секрети, включно з KV.
4. У середовищах, де запускається Next.js, переконайтесь, що пакет `@vercel/kv` доступний (він автоматично працює на Vercel). Якщо ви запускаєте сервер поза Vercel, скористайтеся [Upstash Redis credentials](https://vercel.com/docs/storage/vercel-kv/quickstart) і передайте їх у змінні `KV_URL`, `KV_REST_API_URL`, `KV_REST_API_TOKEN`.
5. Після підключення перевірте, що `process.env.KV_URL` не порожній. Тоді `kvRead` зможе використовувати прямий биндинг без REST-запитів.

## Режим офлайн-снепшоту

Коли доступу до Upstash/Vercel KV немає (локальна розробка без інтернету тощо), можна підкласти дамп кампаній через один із параметрів середовища:

- `KV_CAMPAIGNS_SNAPSHOT_JSON` — рядок із JSON-масивом кампаній або об'єктом `{ index, items }`.
- `KV_CAMPAIGNS_SNAPSHOT_FILE` — шлях до файлу з таким самим JSON.

`kvRead.listCampaigns` автоматично підхопить ці дані, додасть їх до списку індексів і поверне ті самі об'єкти, ніби вони прийшли з KV. Це дозволяє тестеру V1/V2 і вебхукам ManyChat працювати навіть у середовищах без мережі. Щойно з'єднання з KV доступне, фактичні дані мають пріоритет над снепшотом.
