{"version":3,"sources":["../src/core/position.ts","../src/core/types.ts","../src/core/collision.ts","../src/core/sort.ts","../src/core/layout.ts","../src/core/compact-compat.ts","../src/core/compactors.ts","../src/core/responsive.ts"],"names":["getStatics","resolveCompactionCollision"],"mappings":"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","file":"chunk-3WO4SAYB.js","sourcesContent":["/**\n * Position calculation utilities.\n *\n * These functions convert between grid units and pixel positions,\n * and generate CSS styles for grid items.\n */\n\nimport type {\n  Position,\n  PartialPosition,\n  ResizeHandleAxis,\n  PositionStrategy\n} from \"./types.js\";\n\n// ============================================================================\n// CSS Style Generation\n// ============================================================================\n\n/**\n * Generate CSS transform-based positioning styles.\n *\n * Using transforms is more performant than top/left positioning\n * because it doesn't trigger layout recalculations.\n *\n * @param position - Position in pixels\n * @returns CSS style object\n */\nexport function setTransform({\n  top,\n  left,\n  width,\n  height\n}: Position): Record<string, string> {\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Generate CSS top/left positioning styles.\n *\n * Use this when transforms are not suitable (e.g., for printing\n * or when transform causes issues with child elements).\n *\n * @param position - Position in pixels\n * @returns CSS style object\n */\nexport function setTopLeft({\n  top,\n  left,\n  width,\n  height\n}: Position): Record<string, string> {\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Convert a number to a percentage string.\n *\n * @param num - Number to convert (0-1 range typically)\n * @returns Percentage string (e.g., \"50%\")\n */\nexport function perc(num: number): string {\n  return num * 100 + \"%\";\n}\n\n// ============================================================================\n// Resize Direction Handling\n// ============================================================================\n\n/**\n * Constrain width to not overflow container.\n */\nfunction constrainWidth(\n  left: number,\n  currentWidth: number,\n  newWidth: number,\n  containerWidth: number\n): number {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n}\n\n/**\n * Constrain height to not go above container (negative top).\n */\nfunction constrainHeight(\n  top: number,\n  currentHeight: number,\n  newHeight: number\n): number {\n  return top < 0 ? currentHeight : newHeight;\n}\n\n/**\n * Constrain left to not be negative.\n */\nfunction constrainLeft(left: number): number {\n  return Math.max(0, left);\n}\n\n/**\n * Constrain top to not be negative.\n */\nfunction constrainTop(top: number): number {\n  return Math.max(0, top);\n}\n\n// Direction handlers\ntype ResizeHandler = (\n  currentSize: Position,\n  newSize: Position,\n  containerWidth: number\n) => Position;\n\nconst resizeNorth: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { left, height, width } = newSize;\n  const top = currentSize.top - (height - currentSize.height);\n\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\n\nconst resizeEast: ResizeHandler = (currentSize, newSize, containerWidth) => {\n  const { top, left, height, width } = newSize;\n  return {\n    top,\n    height,\n    width: constrainWidth(\n      currentSize.left,\n      currentSize.width,\n      width,\n      containerWidth\n    ),\n    left: constrainLeft(left)\n  };\n};\n\nconst resizeWest: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { top, height, width } = newSize;\n  const left = currentSize.left + currentSize.width - width;\n\n  if (left < 0) {\n    return {\n      height,\n      width: currentSize.left + currentSize.width,\n      top: constrainTop(top),\n      left: 0\n    };\n  }\n\n  return {\n    height,\n    width,\n    top: constrainTop(top),\n    left\n  };\n};\n\nconst resizeSouth: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { top, left, height, width } = newSize;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\n\n// Compound directions (corners)\nconst resizeNorthEast: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeNorth(\n    currentSize,\n    resizeEast(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeNorthWest: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeNorth(\n    currentSize,\n    resizeWest(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeSouthEast: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeSouth(\n    currentSize,\n    resizeEast(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeSouthWest: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeSouth(\n    currentSize,\n    resizeWest(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeHandlerMap: Record<ResizeHandleAxis, ResizeHandler> = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Resize an item in a specific direction, clamping to container bounds.\n *\n * This handles the complex logic of resizing from different edges/corners,\n * ensuring the item doesn't overflow the container.\n *\n * @param direction - Which edge/corner is being dragged\n * @param currentSize - Current position and size\n * @param newSize - Requested new position and size\n * @param containerWidth - Width of the container\n * @returns Constrained position and size\n */\nexport function resizeItemInDirection(\n  direction: ResizeHandleAxis,\n  currentSize: Position,\n  newSize: Position,\n  containerWidth: number\n): Position {\n  const handler = resizeHandlerMap[direction];\n\n  // Fallback if direction not found (shouldn't happen with proper types)\n  if (!handler) {\n    return newSize;\n  }\n\n  return handler(currentSize, { ...currentSize, ...newSize }, containerWidth);\n}\n\n// ============================================================================\n// Position Strategies (v2 Composable Interface)\n// ============================================================================\n\n/**\n * CSS transform-based positioning strategy.\n *\n * Uses CSS transforms for positioning, which is more performant\n * as it doesn't trigger layout recalculations.\n *\n * This is the default strategy.\n */\nexport const transformStrategy: PositionStrategy = {\n  type: \"transform\",\n  scale: 1,\n\n  calcStyle(pos: Position): React.CSSProperties {\n    return setTransform(pos) as React.CSSProperties;\n  },\n\n  calcDragPosition(\n    clientX: number,\n    clientY: number,\n    offsetX: number,\n    offsetY: number\n  ): PartialPosition {\n    return {\n      left: clientX - offsetX,\n      top: clientY - offsetY\n    };\n  }\n};\n\n/**\n * Absolute (top/left) positioning strategy.\n *\n * Uses CSS top/left for positioning. Use this when CSS transforms\n * cause issues (e.g., printing, certain child element positioning).\n */\nexport const absoluteStrategy: PositionStrategy = {\n  type: \"absolute\",\n  scale: 1,\n\n  calcStyle(pos: Position): React.CSSProperties {\n    return setTopLeft(pos) as React.CSSProperties;\n  },\n\n  calcDragPosition(\n    clientX: number,\n    clientY: number,\n    offsetX: number,\n    offsetY: number\n  ): PartialPosition {\n    return {\n      left: clientX - offsetX,\n      top: clientY - offsetY\n    };\n  }\n};\n\n/**\n * Create a scaled transform strategy.\n *\n * Use this when the grid container is inside a scaled element\n * (e.g., `transform: scale(0.5)`). The scale factor adjusts\n * drag/resize calculations to account for the parent transform.\n *\n * @param scale - Scale factor (e.g., 0.5 for half size)\n * @returns Position strategy with scaled calculations\n *\n * @example\n * ```tsx\n * <div style={{ transform: 'scale(0.5)' }}>\n *   <GridLayout positionStrategy={createScaledStrategy(0.5)} />\n * </div>\n * ```\n */\nexport function createScaledStrategy(scale: number): PositionStrategy {\n  return {\n    type: \"transform\",\n    scale,\n\n    calcStyle(pos: Position): React.CSSProperties {\n      return setTransform(pos) as React.CSSProperties;\n    },\n\n    calcDragPosition(\n      clientX: number,\n      clientY: number,\n      offsetX: number,\n      offsetY: number\n    ): PartialPosition {\n      return {\n        left: (clientX - offsetX) / scale,\n        top: (clientY - offsetY) / scale\n      };\n    }\n  };\n}\n\n/** Default position strategy (transform-based) */\nexport const defaultPositionStrategy = transformStrategy;\n","/**\n * Core types for react-grid-layout v2\n *\n * These types are framework-agnostic and define the data structures\n * used by the layout algorithms.\n */\n\n// ============================================================================\n// Resize Handle Types\n// ============================================================================\n\n/**\n * Axis identifiers for resize handles.\n * - Cardinal: 'n', 's', 'e', 'w' (north, south, east, west)\n * - Diagonal: 'ne', 'nw', 'se', 'sw'\n */\nexport type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";\n\n// ============================================================================\n// Layout Item Types\n// ============================================================================\n\n/**\n * A single item in the grid layout.\n *\n * Position (x, y) is in grid units, not pixels.\n * Size (w, h) is in grid units.\n */\nexport interface LayoutItem {\n  /** Unique identifier for this item */\n  i: string;\n\n  /** X position in grid units (0-indexed from left) */\n  x: number;\n\n  /** Y position in grid units (0-indexed from top) */\n  y: number;\n\n  /** Width in grid units */\n  w: number;\n\n  /** Height in grid units */\n  h: number;\n\n  /** Minimum width in grid units */\n  minW?: number;\n\n  /** Minimum height in grid units */\n  minH?: number;\n\n  /** Maximum width in grid units */\n  maxW?: number;\n\n  /** Maximum height in grid units */\n  maxH?: number;\n\n  /**\n   * If true, item cannot be dragged or resized, and other items\n   * will move around it during compaction.\n   */\n  static?: boolean;\n\n  /**\n   * If false, item cannot be dragged (but may still be resizable).\n   * Overrides grid-level isDraggable for this item.\n   */\n  isDraggable?: boolean;\n\n  /**\n   * If false, item cannot be resized (but may still be draggable).\n   * Overrides grid-level isResizable for this item.\n   */\n  isResizable?: boolean;\n\n  /**\n   * Which resize handles to show for this item.\n   * Overrides grid-level resizeHandles for this item.\n   */\n  resizeHandles?: ResizeHandleAxis[];\n\n  /**\n   * If true, item is constrained to the grid container bounds.\n   * Overrides grid-level isBounded for this item.\n   */\n  isBounded?: boolean;\n\n  /**\n   * Internal flag set during drag/resize operations to indicate\n   * the item has moved from its original position.\n   * @internal\n   */\n  moved?: boolean;\n}\n\n/**\n * A layout is a readonly array of layout items.\n * Layouts should be treated as immutable.\n */\nexport type Layout = readonly LayoutItem[];\n\n// ============================================================================\n// Position & Size Types\n// ============================================================================\n\n/**\n * Pixel position and size of an element.\n */\nexport interface Position {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Partial position (just coordinates, no size).\n */\nexport interface PartialPosition {\n  left: number;\n  top: number;\n}\n\n/**\n * Size in pixels.\n */\nexport interface Size {\n  width: number;\n  height: number;\n}\n\n/**\n * Position when dropping an external element onto the grid.\n */\nexport interface DroppingPosition {\n  left: number;\n  top: number;\n  e: Event;\n}\n\n// ============================================================================\n// Event Types\n// ============================================================================\n\n/**\n * Data provided by react-draggable during drag operations.\n */\nexport interface ReactDraggableCallbackData {\n  node: HTMLElement;\n  x?: number;\n  y?: number;\n  deltaX: number;\n  deltaY: number;\n  lastX?: number;\n  lastY?: number;\n}\n\n/**\n * Grid-level drag event data.\n */\nexport interface GridDragEvent {\n  e: Event;\n  node: HTMLElement;\n  newPosition: PartialPosition;\n}\n\n/**\n * Grid-level resize event data.\n */\nexport interface GridResizeEvent {\n  e: Event;\n  node: HTMLElement;\n  size: Size;\n  handle: ResizeHandleAxis;\n}\n\n/**\n * Drag-over event with layer coordinates.\n */\nexport interface DragOverEvent extends MouseEvent {\n  nativeEvent: Event & {\n    layerX: number;\n    layerY: number;\n  };\n}\n\n// ============================================================================\n// Compaction Types\n// ============================================================================\n\n/**\n * Type of compaction to apply to the layout.\n * - 'vertical': Items compact upward (default)\n * - 'horizontal': Items compact leftward\n * - null: No compaction (free-form positioning)\n */\nexport type CompactType = \"horizontal\" | \"vertical\" | null;\n\n// ============================================================================\n// Callback Types\n// ============================================================================\n\n/**\n * Standard callback signature for layout change events.\n *\n * @param layout - The current layout after the change\n * @param oldItem - The item before the change (null if not applicable)\n * @param newItem - The item after the change (null if not applicable)\n * @param placeholder - The placeholder item during drag/resize (null at start)\n * @param event - The DOM event that triggered the change\n * @param element - The DOM element being manipulated (null if not applicable)\n */\nexport type EventCallback = (\n  layout: Layout,\n  oldItem: LayoutItem | null,\n  newItem: LayoutItem | null,\n  placeholder: LayoutItem | null,\n  event: Event,\n  element: HTMLElement | null\n) => void;\n\n/**\n * Callback when layout changes for any reason.\n */\nexport type OnLayoutChangeCallback = (layout: Layout) => void;\n\n// ============================================================================\n// Composable Interfaces (v2 API)\n// ============================================================================\n\n/**\n * Interface for layout compaction strategies.\n *\n * Implement this interface to create custom compaction algorithms.\n *\n * @example\n * ```typescript\n * const myCompactor: Compactor = {\n *   type: 'vertical',\n *   allowOverlap: false,\n *   compact(layout, cols) {\n *     // Custom compaction logic\n *     return compactedLayout;\n *   },\n *   onMove(layout, item, x, y, cols) {\n *     // Handle item movement\n *     return updatedLayout;\n *   }\n * };\n * ```\n */\nexport interface Compactor {\n  /** Compaction type identifier */\n  readonly type: CompactType;\n\n  /** Whether overlapping items are allowed */\n  readonly allowOverlap: boolean;\n\n  /** Whether to prevent collisions instead of pushing items */\n  readonly preventCollision?: boolean;\n\n  /**\n   * Compact the layout.\n   *\n   * @param layout - The layout to compact\n   * @param cols - Number of columns in the grid\n   * @returns The compacted layout\n   */\n  compact(layout: Layout, cols: number): Layout;\n\n  /**\n   * Handle item movement, returning the updated layout.\n   *\n   * @param layout - Current layout\n   * @param item - The item being moved\n   * @param x - New x position\n   * @param y - New y position\n   * @param cols - Number of columns\n   * @returns Updated layout after the move\n   */\n  onMove(\n    layout: Layout,\n    item: LayoutItem,\n    x: number,\n    y: number,\n    cols: number\n  ): Layout;\n}\n\n/**\n * Interface for CSS positioning strategies.\n *\n * Implement this interface to customize how items are positioned in the DOM.\n * Built-in strategies: transformStrategy, absoluteStrategy.\n *\n * @example\n * ```typescript\n * // Use transform-based positioning (default, better performance)\n * <GridLayout positionStrategy={transformStrategy} />\n *\n * // Use top/left positioning (for environments where transforms cause issues)\n * <GridLayout positionStrategy={absoluteStrategy} />\n *\n * // Use scaled transforms (for scaled containers)\n * <GridLayout positionStrategy={createScaledStrategy(0.5)} />\n * ```\n */\nexport interface PositionStrategy {\n  /** Strategy type identifier */\n  readonly type: \"transform\" | \"absolute\";\n\n  /** Scale factor for drag/resize calculations */\n  readonly scale: number;\n\n  /**\n   * Convert pixel position to CSS style object.\n   *\n   * @param pos - Position in pixels\n   * @returns CSS properties for positioning the element\n   */\n  calcStyle(pos: Position): React.CSSProperties;\n\n  /**\n   * Calculate position during drag operations, accounting for transforms and scale.\n   *\n   * @param clientX - Mouse client X position\n   * @param clientY - Mouse client Y position\n   * @param offsetX - Offset from element origin X\n   * @param offsetY - Offset from element origin Y\n   * @returns Adjusted left/top position\n   */\n  calcDragPosition(\n    clientX: number,\n    clientY: number,\n    offsetX: number,\n    offsetY: number\n  ): PartialPosition;\n}\n\n// ============================================================================\n// Grid Configuration Types (v2 Composable Interfaces)\n// ============================================================================\n\n/**\n * Grid measurement configuration.\n * Groups all grid metrics (columns, row height, margins).\n */\nexport interface GridConfig {\n  /** Number of columns in the grid (default: 12) */\n  cols: number;\n\n  /** Height of a single row in pixels (default: 150) */\n  rowHeight: number;\n\n  /** [horizontal, vertical] margin between items in pixels (default: [10, 10]) */\n  margin: readonly [number, number];\n\n  /** [horizontal, vertical] padding inside the container (default: null, uses margin) */\n  containerPadding: readonly [number, number] | null;\n\n  /** Maximum number of rows (default: Infinity) */\n  maxRows: number;\n}\n\n/** Default grid configuration */\nexport const defaultGridConfig: GridConfig = {\n  cols: 12,\n  rowHeight: 150,\n  margin: [10, 10],\n  containerPadding: null,\n  maxRows: Infinity\n};\n\n/**\n * Drag behavior configuration.\n * Groups all drag-related settings.\n */\nexport interface DragConfig {\n  /** Whether items can be dragged (default: true) */\n  enabled: boolean;\n\n  /** Whether items are bounded to the container (default: false) */\n  bounded: boolean;\n\n  /** CSS selector for drag handle (e.g., '.drag-handle') */\n  handle?: string;\n\n  /** CSS selector for elements that should not trigger drag */\n  cancel?: string;\n\n  /**\n   * Minimum pixels to move before drag starts.\n   * Helps distinguish click from drag (fixes #1341, #1401).\n   * @default 3\n   */\n  threshold: number;\n}\n\n/** Default drag configuration */\nexport const defaultDragConfig: DragConfig = {\n  enabled: true,\n  bounded: false,\n  threshold: 3\n};\n\n/**\n * Resize behavior configuration.\n * Groups all resize-related settings.\n */\nexport interface ResizeConfig {\n  /** Whether items can be resized (default: true) */\n  enabled: boolean;\n\n  /** Which resize handles to show (default: ['se']) */\n  handles: readonly ResizeHandleAxis[];\n\n  /**\n   * Custom resize handle component.\n   * Can be a React node or a function that receives the axis.\n   */\n  handleComponent?:\n    | React.ReactNode\n    | ((\n        axis: ResizeHandleAxis,\n        ref: React.Ref<HTMLElement>\n      ) => React.ReactNode);\n}\n\n/** Default resize configuration */\nexport const defaultResizeConfig: ResizeConfig = {\n  enabled: true,\n  handles: [\"se\"]\n};\n\n/**\n * Drop configuration (for dropping external elements).\n * Groups all drop-related settings.\n */\nexport interface DropConfig {\n  /** Whether external elements can be dropped on the grid (default: false) */\n  enabled: boolean;\n\n  /** Default size for dropped items (default: { w: 1, h: 1 }) */\n  defaultItem: { w: number; h: number };\n\n  /**\n   * Called when dragging over the grid.\n   * Return dimensions to override defaultItem, or false to reject the drop.\n   */\n  onDragOver?: (e: DragEvent) => { w?: number; h?: number } | false | void;\n}\n\n/** Default drop configuration */\nexport const defaultDropConfig: DropConfig = {\n  enabled: false,\n  defaultItem: { w: 1, h: 1 }\n};\n\n// ============================================================================\n// Responsive Types\n// ============================================================================\n\n/**\n * Breakpoint name (e.g., 'lg', 'md', 'sm', 'xs', 'xxs').\n */\nexport type Breakpoint = string;\n\n/**\n * Map of breakpoint name to pixel width.\n * Generic type B allows custom breakpoint strings.\n */\nexport type Breakpoints<B extends Breakpoint = Breakpoint> = Record<B, number>;\n\n/**\n * Map of breakpoint name to number of columns.\n * Generic type B allows custom breakpoint strings.\n */\nexport type BreakpointCols<B extends Breakpoint = Breakpoint> = Record<\n  B,\n  number\n>;\n\n/**\n * Map of breakpoint name to layout.\n * Generic type B allows custom breakpoint strings.\n */\nexport type ResponsiveLayouts<B extends Breakpoint = Breakpoint> = Partial<\n  Record<B, Layout>\n>;\n\n/**\n * Callback when breakpoint changes.\n */\nexport type OnBreakpointChangeCallback<B extends Breakpoint = Breakpoint> = (\n  newBreakpoint: B,\n  cols: number\n) => void;\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Makes all properties in T mutable (removes readonly).\n */\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Deep partial - all properties and nested properties are optional.\n */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Extract the element type from an array type.\n */\nexport type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;\n","/**\n * Collision detection utilities for grid layouts.\n *\n * These functions determine if and where layout items overlap.\n */\n\nimport type { Layout, LayoutItem } from \"./types.js\";\n\n/**\n * Check if two layout items collide (overlap).\n *\n * Two items collide if their bounding boxes overlap and they are\n * not the same item.\n *\n * @param l1 - First layout item\n * @param l2 - Second layout item\n * @returns true if the items collide\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\n  // Same element - can't collide with itself\n  if (l1.i === l2.i) return false;\n\n  // Check if bounding boxes don't overlap (any gap means no collision)\n  if (l1.x + l1.w <= l2.x) return false; // l1 is completely left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is completely right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is completely above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is completely below l2\n\n  // Bounding boxes overlap\n  return true;\n}\n\n/**\n * Find the first item in the layout that collides with the given item.\n *\n * @param layout - Layout to search\n * @param layoutItem - Item to check for collisions\n * @returns The first colliding item, or undefined if none\n */\nexport function getFirstCollision(\n  layout: Layout,\n  layoutItem: LayoutItem\n): LayoutItem | undefined {\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined && collides(item, layoutItem)) {\n      return item;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Find all items in the layout that collide with the given item.\n *\n * @param layout - Layout to search\n * @param layoutItem - Item to check for collisions\n * @returns Array of all colliding items (may be empty)\n */\nexport function getAllCollisions(\n  layout: Layout,\n  layoutItem: LayoutItem\n): LayoutItem[] {\n  return layout.filter((l): l is LayoutItem => collides(l, layoutItem));\n}\n","/**\n * Sorting utilities for grid layouts.\n *\n * These functions sort layout items for compaction and iteration.\n */\n\nimport type { CompactType, Layout, LayoutItem } from \"./types.js\";\n\n/**\n * Sort layout items based on the compaction type.\n *\n * - Vertical compaction: sort by row (y) then column (x)\n * - Horizontal compaction: sort by column (x) then row (y)\n * - No compaction (null): return original order\n *\n * Does not modify the original layout.\n *\n * @param layout - Layout to sort\n * @param compactType - Type of compaction\n * @returns Sorted layout\n */\nexport function sortLayoutItems(\n  layout: Layout,\n  compactType: CompactType\n): LayoutItem[] {\n  if (compactType === \"horizontal\") {\n    return sortLayoutItemsByColRow(layout);\n  }\n  if (compactType === \"vertical\") {\n    return sortLayoutItemsByRowCol(layout);\n  }\n  // No compaction - return a copy to maintain immutability\n  return [...layout];\n}\n\n/**\n * Sort layout items by row ascending, then column ascending.\n *\n * Items are ordered from top-left to bottom-right, row by row.\n * This is the natural reading order for vertical compaction.\n *\n * Does not modify the original layout.\n *\n * @param layout - Layout to sort\n * @returns Sorted array of layout items\n */\nexport function sortLayoutItemsByRowCol(layout: Layout): LayoutItem[] {\n  return [...layout].sort((a, b) => {\n    // Primary sort by row (y)\n    if (a.y !== b.y) {\n      return a.y - b.y;\n    }\n    // Secondary sort by column (x)\n    return a.x - b.x;\n  });\n}\n\n/**\n * Sort layout items by column ascending, then row ascending.\n *\n * Items are ordered from top-left to bottom-right, column by column.\n * This is the natural order for horizontal compaction.\n *\n * Does not modify the original layout.\n *\n * @param layout - Layout to sort\n * @returns Sorted array of layout items\n */\nexport function sortLayoutItemsByColRow(layout: Layout): LayoutItem[] {\n  return [...layout].sort((a, b) => {\n    // Primary sort by column (x)\n    if (a.x !== b.x) {\n      return a.x - b.x;\n    }\n    // Secondary sort by row (y)\n    return a.y - b.y;\n  });\n}\n","/**\n * Core layout manipulation utilities.\n *\n * These functions create, modify, and query grid layouts.\n * All functions treat layouts as immutable - they return new arrays/objects.\n */\n\nimport type { CompactType, Layout, LayoutItem, Mutable } from \"./types.js\";\nimport { getAllCollisions, getFirstCollision } from \"./collision.js\";\nimport { sortLayoutItems } from \"./sort.js\";\n\n// ============================================================================\n// Layout Queries\n// ============================================================================\n\n/**\n * Get the bottom-most Y coordinate of the layout.\n *\n * This is the Y position plus height of the lowest item.\n *\n * @param layout - Layout to measure\n * @returns The bottom Y coordinate (0 if layout is empty)\n */\nexport function bottom(layout: Layout): number {\n  let max = 0;\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined) {\n      const bottomY = item.y + item.h;\n      if (bottomY > max) max = bottomY;\n    }\n  }\n  return max;\n}\n\n/**\n * Get a layout item by its ID.\n *\n * @param layout - Layout to search\n * @param id - Item ID to find\n * @returns The layout item, or undefined if not found\n */\nexport function getLayoutItem(\n  layout: Layout,\n  id: string\n): LayoutItem | undefined {\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined && item.i === id) {\n      return item;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Get all static items from the layout.\n *\n * Static items cannot be moved or resized by the user.\n *\n * @param layout - Layout to filter\n * @returns Array of static layout items\n */\nexport function getStatics(layout: Layout): LayoutItem[] {\n  return layout.filter((l): l is LayoutItem => l.static === true);\n}\n\n// ============================================================================\n// Layout Cloning\n// ============================================================================\n\n/**\n * Clone a layout item.\n *\n * Creates a shallow copy with all properties preserved.\n * Boolean properties are normalized (undefined becomes false).\n *\n * @param layoutItem - Item to clone\n * @returns A new layout item with the same properties\n */\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\n  return {\n    i: layoutItem.i,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    w: layoutItem.w,\n    h: layoutItem.h,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Clone an entire layout.\n *\n * Creates a new array with cloned items.\n *\n * @param layout - Layout to clone\n * @returns A new layout with cloned items\n */\nexport function cloneLayout(layout: Layout): LayoutItem[] {\n  const newLayout: LayoutItem[] = new Array(layout.length);\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined) {\n      newLayout[i] = cloneLayoutItem(item);\n    }\n  }\n  return newLayout;\n}\n\n// ============================================================================\n// Layout Modification\n// ============================================================================\n\n/**\n * Replace a layout item in a layout.\n *\n * Returns a new layout with the item replaced. Other items are not cloned.\n *\n * @param layout - Layout to modify\n * @param layoutItem - New item (matched by `i` property)\n * @returns New layout with the item replaced\n */\nexport function modifyLayout(\n  layout: Layout,\n  layoutItem: LayoutItem\n): LayoutItem[] {\n  const newLayout: LayoutItem[] = new Array(layout.length);\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item !== undefined) {\n      if (layoutItem.i === item.i) {\n        newLayout[i] = layoutItem;\n      } else {\n        newLayout[i] = item;\n      }\n    }\n  }\n  return newLayout;\n}\n\n/**\n * Apply a transformation to a layout item.\n *\n * Finds the item by key, clones it, applies the callback, and returns\n * a new layout with the modified item.\n *\n * @param layout - Layout to modify\n * @param itemKey - Key of the item to modify\n * @param cb - Callback that receives the cloned item and returns the modified item\n * @returns Tuple of [new layout, modified item or null if not found]\n */\nexport function withLayoutItem(\n  layout: Layout,\n  itemKey: string,\n  cb: (item: LayoutItem) => LayoutItem\n): [LayoutItem[], LayoutItem | null] {\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) {\n    return [[...layout], null];\n  }\n\n  // Clone, then modify via callback\n  item = cb(cloneLayoutItem(item));\n  const newLayout = modifyLayout(layout, item);\n\n  return [newLayout, item];\n}\n\n// ============================================================================\n// Bounds Correction\n// ============================================================================\n\n/**\n * Ensure all layout items fit within the grid bounds.\n *\n * - Items overflowing right are moved left\n * - Items overflowing left are moved to x=0 and clamped to grid width\n * - Static items that collide with other statics are moved down\n *\n * **IMPORTANT**: This function mutates the layout items in place for performance.\n * The type signature uses `Mutable<LayoutItem>[]` to make this explicit.\n * Clone the layout first (e.g., with `cloneLayout()`) if you need immutability.\n *\n * @param layout - Layout to correct (items WILL be mutated)\n * @param bounds - Grid bounds\n * @returns The same layout array (for chaining)\n */\nexport function correctBounds(\n  layout: Mutable<LayoutItem>[],\n  bounds: { cols: number }\n): LayoutItem[] {\n  const collidesWith = getStatics(layout);\n\n  for (let i = 0; i < layout.length; i++) {\n    const l = layout[i];\n    if (l === undefined) continue;\n\n    // Overflows right\n    if (l.x + l.w > bounds.cols) {\n      l.x = bounds.cols - l.w;\n    }\n\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) {\n      collidesWith.push(l);\n    } else {\n      // Static items that collide with other statics must be moved down\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n\n// ============================================================================\n// Move Operations\n// ============================================================================\n\n/**\n * Move a layout element to a new position.\n *\n * Handles collision detection and cascading movements.\n * Does not compact the layout - call `compact()` separately.\n *\n * **Note**: This function mutates the `l` parameter directly for performance.\n * The item's x, y, and moved properties will be modified. Callers should\n * ideally pass a cloned item if they need to preserve the original.\n *\n * @param layout - Full layout\n * @param l - Item to move (will be mutated)\n * @param x - New X position (or undefined to keep current)\n * @param y - New Y position (or undefined to keep current)\n * @param isUserAction - True if this is a direct user action (affects collision resolution)\n * @param preventCollision - True to prevent movement if it causes collision\n * @param compactType - Compaction type for collision resolution\n * @param cols - Number of columns in the grid\n * @param allowOverlap - True to allow items to overlap\n * @returns The updated layout\n */\nexport function moveElement(\n  layout: Layout,\n  l: LayoutItem,\n  x: number | undefined,\n  y: number | undefined,\n  isUserAction: boolean | undefined,\n  preventCollision: boolean | undefined,\n  compactType: CompactType,\n  cols: number,\n  allowOverlap?: boolean\n): LayoutItem[] {\n  // Static items can't be moved unless explicitly draggable\n  if (l.static && l.isDraggable !== true) {\n    return [...layout];\n  }\n\n  // Short-circuit if position unchanged\n  if (l.y === y && l.x === x) {\n    return [...layout];\n  }\n\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // Update position (mutates l directly - see JSDoc note)\n  if (typeof x === \"number\") (l as Mutable<LayoutItem>).x = x;\n  if (typeof y === \"number\") (l as Mutable<LayoutItem>).y = y;\n  (l as Mutable<LayoutItem>).moved = true;\n\n  // Sort for proper collision detection order\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp =\n    compactType === \"vertical\" && typeof y === \"number\"\n      ? oldY >= y\n      : compactType === \"horizontal\" && typeof x === \"number\"\n        ? oldX >= x\n        : false;\n\n  if (movingUp) {\n    sorted = sorted.reverse();\n  }\n\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // Handle overlap mode - just clone and return\n  if (hasCollisions && allowOverlap) {\n    return cloneLayout(layout);\n  }\n\n  // Handle prevent collision mode - revert position\n  // Return same reference to signal no change occurred\n  if (hasCollisions && preventCollision) {\n    (l as Mutable<LayoutItem>).x = oldX;\n    (l as Mutable<LayoutItem>).y = oldY;\n    (l as Mutable<LayoutItem>).moved = false;\n    return layout as LayoutItem[];\n  }\n\n  // Resolve collisions by moving other items\n  let resultLayout: LayoutItem[] = [...layout];\n  for (let i = 0; i < collisions.length; i++) {\n    const collision = collisions[i];\n    if (collision === undefined) continue;\n\n    // Skip already-moved items to prevent infinite loops\n    if (collision.moved) continue;\n\n    // Static items can't be moved - move the dragged item instead\n    if (collision.static) {\n      resultLayout = moveElementAwayFromCollision(\n        resultLayout,\n        collision,\n        l,\n        isUserAction,\n        compactType,\n        cols\n      );\n    } else {\n      resultLayout = moveElementAwayFromCollision(\n        resultLayout,\n        l,\n        collision,\n        isUserAction,\n        compactType,\n        cols\n      );\n    }\n  }\n\n  return resultLayout;\n}\n\n/**\n * Move an item away from a collision.\n *\n * Attempts to move the item up/left first if there's room,\n * otherwise moves it down/right.\n *\n * @param layout - Full layout\n * @param collidesWith - The item being collided with\n * @param itemToMove - The item to move away\n * @param isUserAction - True if this is a direct user action\n * @param compactType - Compaction type\n * @param cols - Number of columns\n * @returns Updated layout\n */\nexport function moveElementAwayFromCollision(\n  layout: Layout,\n  collidesWith: LayoutItem,\n  itemToMove: LayoutItem,\n  isUserAction: boolean | undefined,\n  compactType: CompactType,\n  cols: number\n): LayoutItem[] {\n  const compactH = compactType === \"horizontal\";\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static;\n\n  // Try to move up/left first (only on primary collision from user action)\n  if (isUserAction) {\n    isUserAction = false; // Only try this once\n\n    // Create a fake item to test if there's room above/left\n    const fakeItem: LayoutItem = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth =\n      firstCollision !== undefined &&\n      firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest =\n      firstCollision !== undefined &&\n      collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision above/left - we can move there\n    if (!firstCollision) {\n      return moveElement(\n        layout,\n        itemToMove,\n        compactH ? fakeItem.x : undefined,\n        compactV ? fakeItem.y : undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n      );\n    }\n\n    // Handle specific collision cases\n    if (collisionNorth && compactV) {\n      return moveElement(\n        layout,\n        itemToMove,\n        undefined,\n        itemToMove.y + 1,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n      );\n    }\n\n    if (collisionNorth && compactType === null) {\n      // Swap positions in free-form mode\n      (collidesWith as Mutable<LayoutItem>).y = itemToMove.y;\n      (itemToMove as Mutable<LayoutItem>).y = itemToMove.y + itemToMove.h;\n      return [...layout];\n    }\n\n    if (collisionWest && compactH) {\n      return moveElement(\n        layout,\n        collidesWith,\n        itemToMove.x,\n        undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n      );\n    }\n  }\n\n  // Default: move down/right by 1\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n\n  if (newX === undefined && newY === undefined) {\n    return [...layout];\n  }\n\n  return moveElement(\n    layout,\n    itemToMove,\n    newX,\n    newY,\n    isUserAction,\n    preventCollision,\n    compactType,\n    cols\n  );\n}\n\n// ============================================================================\n// Validation\n// ============================================================================\n\n/**\n * Validate that a layout has the required properties.\n *\n * @param layout - Layout to validate\n * @param contextName - Name for error messages\n * @throws Error if layout is invalid\n */\nexport function validateLayout(\n  layout: Layout,\n  contextName: string = \"Layout\"\n): void {\n  const requiredProps = [\"x\", \"y\", \"w\", \"h\"] as const;\n\n  if (!Array.isArray(layout)) {\n    throw new Error(`${contextName} must be an array!`);\n  }\n\n  for (let i = 0; i < layout.length; i++) {\n    const item = layout[i];\n    if (item === undefined) continue;\n\n    for (const key of requiredProps) {\n      const value = item[key];\n      if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new Error(\n          `ReactGridLayout: ${contextName}[${i}].${key} must be a number! ` +\n            `Received: ${String(value)} (${typeof value})`\n        );\n      }\n    }\n\n    if (item.i !== undefined && typeof item.i !== \"string\") {\n      throw new Error(\n        `ReactGridLayout: ${contextName}[${i}].i must be a string! ` +\n          `Received: ${String(item.i)} (${typeof item.i})`\n      );\n    }\n  }\n}\n","/**\n * Legacy compaction API - backwards compatibility layer.\n *\n * This file implements the exact v1 compaction algorithm for backwards compatibility.\n * The algorithm matches lib/utils.js compact/compactItem functions exactly.\n */\n\nimport type { CompactType, Layout, LayoutItem, Mutable } from \"./types.js\";\nimport { cloneLayoutItem, bottom } from \"./layout.js\";\nimport { getFirstCollision, collides } from \"./collision.js\";\nimport { sortLayoutItems } from \"./sort.js\";\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Get all static items from a layout\n */\nfunction getStatics(layout: Layout): LayoutItem[] {\n  return layout.filter(l => l.static);\n}\n\nconst heightWidth: { x: \"w\"; y: \"h\" } = { x: \"w\", y: \"h\" };\n\n/**\n * Before moving item down/right, check if movement will cause collisions\n * and move those items first. This is the recursive collision resolver.\n */\nfunction resolveCompactionCollision(\n  layout: Layout,\n  item: LayoutItem,\n  moveToCoord: number,\n  axis: \"x\" | \"y\"\n): void {\n  const sizeProp = heightWidth[axis];\n  (item as Mutable<LayoutItem>)[axis] += 1;\n\n  const itemIndex = layout.findIndex(l => l.i === item.i);\n\n  // Go through each item we collide with\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    if (otherItem === undefined) continue;\n\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this element\n    // We can do this because it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(\n        layout,\n        otherItem,\n        moveToCoord + item[sizeProp],\n        axis\n      );\n    }\n  }\n\n  (item as Mutable<LayoutItem>)[axis] = moveToCoord;\n}\n\n/**\n * Compact a single item in the layout.\n *\n * This is the exact algorithm from lib/utils.js compactItem.\n */\nfunction compactItemInternal(\n  compareWith: Layout,\n  l: LayoutItem,\n  compactType: CompactType,\n  cols: number,\n  fullLayout: Layout,\n  allowOverlap: boolean | undefined,\n  b: number | undefined\n): LayoutItem {\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    if (typeof b === \"number\") {\n      (l as Mutable<LayoutItem>).y = Math.min(b, l.y);\n    } else {\n      (l as Mutable<LayoutItem>).y = Math.min(bottom(compareWith), l.y);\n    }\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      (l as Mutable<LayoutItem>).y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      (l as Mutable<LayoutItem>).x--;\n    }\n  }\n\n  // Move it down/right, and keep moving if it's colliding.\n  let collision: LayoutItem | undefined;\n  // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n  while (\n    (collision = getFirstCollision(compareWith, l)) !== undefined &&\n    !(compactType === null && allowOverlap)\n  ) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collision.x + collision.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collision.y + collision.h, \"y\");\n    }\n\n    // Since we can't grow without bounds horizontally, if we've overflown,\n    // let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      (l as Mutable<LayoutItem>).x = cols - l.w;\n      (l as Mutable<LayoutItem>).y++;\n      // Also move element as left as we can\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        (l as Mutable<LayoutItem>).x--;\n      }\n    }\n  }\n\n  // Ensure that there are no negative positions\n  (l as Mutable<LayoutItem>).y = Math.max(l.y, 0);\n  (l as Mutable<LayoutItem>).x = Math.max(l.x, 0);\n\n  return l;\n}\n\n// ============================================================================\n// Public API\n// ============================================================================\n\n/**\n * Compact a layout by removing gaps between items.\n *\n * This is the exact algorithm from lib/utils.js compact function.\n *\n * @param layout - Layout to compact\n * @param compactType - 'vertical', 'horizontal', or null\n * @param cols - Number of columns in the grid\n * @param allowOverlap - If true, overlapping is allowed\n * @returns Compacted layout\n */\nexport function compact(\n  layout: Layout,\n  compactType: CompactType,\n  cols: number,\n  allowOverlap?: boolean\n): LayoutItem[] {\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We keep track of the bottom position.\n  let b = bottom(compareWith);\n  // We go through the items by row and column (or col and row for horizontal).\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out: LayoutItem[] = new Array(layout.length);\n\n  for (let i = 0; i < sorted.length; i++) {\n    const sortedItem = sorted[i];\n    if (sortedItem === undefined) continue;\n\n    let l = cloneLayoutItem(sortedItem);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItemInternal(\n        compareWith,\n        l,\n        compactType,\n        cols,\n        sorted,\n        allowOverlap,\n        b\n      );\n      b = Math.max(b, l.y + l.h);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    const originalIndex = layout.indexOf(sortedItem);\n    out[originalIndex] = l;\n\n    // Clear moved flag, if it exists.\n    (l as Mutable<LayoutItem>).moved = false;\n  }\n\n  return out;\n}\n\n/**\n * Compact a single item within the layout.\n *\n * @deprecated Use compact() instead, which handles the full layout.\n */\nexport function compactItem(\n  compareWith: Layout,\n  l: LayoutItem,\n  compactType: CompactType,\n  cols: number,\n  fullLayout: Layout,\n  allowOverlap: boolean | undefined,\n  maxY: number | undefined\n): LayoutItem {\n  return compactItemInternal(\n    compareWith,\n    cloneLayoutItem(l),\n    compactType,\n    cols,\n    fullLayout,\n    allowOverlap,\n    maxY\n  );\n}\n","/**\n * Compactor implementations.\n *\n * Compactors are pluggable strategies for removing gaps between grid items.\n * Use the Compactor interface to create custom compaction algorithms.\n */\n\nimport type { Compactor, Layout, LayoutItem, Mutable } from \"./types.js\";\nimport { getFirstCollision } from \"./collision.js\";\nimport { sortLayoutItemsByRowCol, sortLayoutItemsByColRow } from \"./sort.js\";\nimport { bottom, cloneLayoutItem, getStatics, cloneLayout } from \"./layout.js\";\nimport { collides } from \"./collision.js\";\n\n// ============================================================================\n// Helpers for Custom Compactors\n// ============================================================================\n\n/**\n * Resolve a compaction collision by moving items.\n *\n * Before moving an item to a position, checks if that movement would\n * cause collisions and recursively moves those items first.\n *\n * Useful for implementing custom compactors.\n *\n * @param layout - Full layout (must be sorted for optimization)\n * @param item - Item being moved (will be mutated)\n * @param moveToCoord - Target coordinate\n * @param axis - Which axis to move on ('x' or 'y')\n */\nexport function resolveCompactionCollision(\n  layout: Layout,\n  item: LayoutItem,\n  moveToCoord: number,\n  axis: \"x\" | \"y\"\n): void {\n  const sizeProp = axis === \"x\" ? \"w\" : \"h\";\n\n  // Temporarily increment position to check for collisions\n  (item as Mutable<LayoutItem>)[axis] += 1;\n\n  const itemIndex = layout.findIndex(l => l.i === item.i);\n\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    if (otherItem === undefined) continue;\n    if (otherItem.static) continue;\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(\n        layout,\n        otherItem,\n        moveToCoord + item[sizeProp],\n        axis\n      );\n    }\n  }\n\n  (item as Mutable<LayoutItem>)[axis] = moveToCoord;\n}\n\n/**\n * Compact a single item vertically (move up).\n *\n * Moves the item as far up as possible without colliding.\n * Useful for implementing custom vertical compactors.\n *\n * @param compareWith - Items to check for collisions\n * @param l - Item to compact (will be mutated)\n * @param fullLayout - Full layout for collision resolution\n * @param maxY - Maximum Y to start from\n * @returns The compacted item\n */\nexport function compactItemVertical(\n  compareWith: Layout,\n  l: LayoutItem,\n  fullLayout: Layout,\n  maxY: number\n): LayoutItem {\n  // Limit Y to the current bottom\n  (l as Mutable<LayoutItem>).y = Math.min(maxY, l.y);\n\n  // Move up as far as possible\n  while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n    (l as Mutable<LayoutItem>).y--;\n  }\n\n  // Resolve collisions by moving down\n  let collision: LayoutItem | undefined;\n  while ((collision = getFirstCollision(compareWith, l)) !== undefined) {\n    resolveCompactionCollision(fullLayout, l, collision.y + collision.h, \"y\");\n  }\n\n  (l as Mutable<LayoutItem>).y = Math.max(l.y, 0);\n  return l;\n}\n\n/**\n * Compact a single item horizontally (move left).\n *\n * Moves the item as far left as possible without colliding.\n * Wraps to the next row if it overflows.\n * Useful for implementing custom horizontal compactors.\n *\n * @param compareWith - Items to check for collisions\n * @param l - Item to compact (will be mutated)\n * @param cols - Number of columns in the grid\n * @param fullLayout - Full layout for collision resolution\n * @returns The compacted item\n */\nexport function compactItemHorizontal(\n  compareWith: Layout,\n  l: LayoutItem,\n  cols: number,\n  fullLayout: Layout\n): LayoutItem {\n  // Move left as far as possible\n  while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n    (l as Mutable<LayoutItem>).x--;\n  }\n\n  // Resolve collisions\n  let collision: LayoutItem | undefined;\n  while ((collision = getFirstCollision(compareWith, l)) !== undefined) {\n    resolveCompactionCollision(fullLayout, l, collision.x + collision.w, \"x\");\n\n    // Horizontal overflow: wrap to next row\n    if (l.x + l.w > cols) {\n      (l as Mutable<LayoutItem>).x = cols - l.w;\n      (l as Mutable<LayoutItem>).y++;\n\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        (l as Mutable<LayoutItem>).x--;\n      }\n    }\n  }\n\n  (l as Mutable<LayoutItem>).x = Math.max(l.x, 0);\n  return l;\n}\n\n// ============================================================================\n// Vertical Compactor\n// ============================================================================\n\n/**\n * Vertical compactor - moves items up to fill gaps.\n *\n * Items are sorted by row then column, and each item is moved\n * as far up as possible without overlapping other items.\n *\n * This is the default compaction mode for react-grid-layout.\n */\nexport const verticalCompactor: Compactor = {\n  type: \"vertical\",\n  allowOverlap: false,\n\n  compact(layout: Layout, _cols: number): Layout {\n    const compareWith = getStatics(layout);\n    let maxY = bottom(compareWith);\n    const sorted = sortLayoutItemsByRowCol(layout);\n    const out: LayoutItem[] = new Array(layout.length);\n\n    for (let i = 0; i < sorted.length; i++) {\n      const sortedItem = sorted[i];\n      if (sortedItem === undefined) continue;\n\n      let l = cloneLayoutItem(sortedItem);\n\n      if (!l.static) {\n        l = compactItemVertical(compareWith, l, sorted, maxY);\n        maxY = Math.max(maxY, l.y + l.h);\n        compareWith.push(l);\n      }\n\n      const originalIndex = layout.indexOf(sortedItem);\n      out[originalIndex] = l;\n      l.moved = false;\n    }\n\n    return out;\n  },\n\n  onMove(\n    layout: Layout,\n    item: LayoutItem,\n    x: number,\n    y: number,\n    _cols: number\n  ): Layout {\n    // Simple move - compact() will be called after\n    const newLayout = cloneLayout(layout);\n    const movedItem = newLayout.find(l => l.i === item.i);\n    if (movedItem) {\n      movedItem.x = x;\n      movedItem.y = y;\n      movedItem.moved = true;\n    }\n    return newLayout;\n  }\n};\n\n// ============================================================================\n// Horizontal Compactor\n// ============================================================================\n\n/**\n * Horizontal compactor - moves items left to fill gaps.\n *\n * Items are sorted by column then row, and each item is moved\n * as far left as possible without overlapping other items.\n */\nexport const horizontalCompactor: Compactor = {\n  type: \"horizontal\",\n  allowOverlap: false,\n\n  compact(layout: Layout, cols: number): Layout {\n    const compareWith = getStatics(layout);\n    const sorted = sortLayoutItemsByColRow(layout);\n    const out: LayoutItem[] = new Array(layout.length);\n\n    for (let i = 0; i < sorted.length; i++) {\n      const sortedItem = sorted[i];\n      if (sortedItem === undefined) continue;\n\n      let l = cloneLayoutItem(sortedItem);\n\n      if (!l.static) {\n        l = compactItemHorizontal(compareWith, l, cols, sorted);\n        compareWith.push(l);\n      }\n\n      const originalIndex = layout.indexOf(sortedItem);\n      out[originalIndex] = l;\n      l.moved = false;\n    }\n\n    return out;\n  },\n\n  onMove(\n    layout: Layout,\n    item: LayoutItem,\n    x: number,\n    y: number,\n    _cols: number\n  ): Layout {\n    const newLayout = cloneLayout(layout);\n    const movedItem = newLayout.find(l => l.i === item.i);\n    if (movedItem) {\n      movedItem.x = x;\n      movedItem.y = y;\n      movedItem.moved = true;\n    }\n    return newLayout;\n  }\n};\n\n// ============================================================================\n// No Compaction\n// ============================================================================\n\n/**\n * No compaction - items stay where placed.\n *\n * Use this for free-form layouts where items can be placed anywhere.\n * Items will not automatically move to fill gaps.\n */\nexport const noCompactor: Compactor = {\n  type: null,\n  allowOverlap: false,\n\n  compact(layout: Layout, _cols: number): Layout {\n    // No compaction - just clone to maintain immutability\n    return cloneLayout(layout);\n  },\n\n  onMove(\n    layout: Layout,\n    item: LayoutItem,\n    x: number,\n    y: number,\n    _cols: number\n  ): Layout {\n    const newLayout = cloneLayout(layout);\n    const movedItem = newLayout.find(l => l.i === item.i);\n    if (movedItem) {\n      movedItem.x = x;\n      movedItem.y = y;\n      movedItem.moved = true;\n    }\n    return newLayout;\n  }\n};\n\n// ============================================================================\n// Overlap-Allowing Variants\n// ============================================================================\n\n/**\n * Vertical compactor that allows overlapping items.\n *\n * Items compact upward but are allowed to overlap each other.\n * Useful for layered layouts or when collision detection is handled externally.\n */\nexport const verticalOverlapCompactor: Compactor = {\n  ...verticalCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, _cols: number): Layout {\n    // With overlap allowed, just clone without moving\n    return cloneLayout(layout);\n  }\n};\n\n/**\n * Horizontal compactor that allows overlapping items.\n */\nexport const horizontalOverlapCompactor: Compactor = {\n  ...horizontalCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, _cols: number): Layout {\n    return cloneLayout(layout);\n  }\n};\n\n// ============================================================================\n// Factory Function\n// ============================================================================\n\n/**\n * Get a compactor by type.\n *\n * This is a convenience function for backwards compatibility with the\n * string-based compactType API.\n *\n * @param compactType - 'vertical', 'horizontal', or null\n * @param allowOverlap - Whether to allow overlapping items\n * @returns The appropriate Compactor\n */\nexport function getCompactor(\n  compactType: \"vertical\" | \"horizontal\" | null,\n  allowOverlap: boolean = false,\n  preventCollision: boolean = false\n): Compactor {\n  let baseCompactor: Compactor;\n\n  if (allowOverlap) {\n    if (compactType === \"vertical\") baseCompactor = verticalOverlapCompactor;\n    else if (compactType === \"horizontal\")\n      baseCompactor = horizontalOverlapCompactor;\n    else baseCompactor = noCompactor;\n  } else {\n    if (compactType === \"vertical\") baseCompactor = verticalCompactor;\n    else if (compactType === \"horizontal\") baseCompactor = horizontalCompactor;\n    else baseCompactor = noCompactor;\n  }\n\n  // Return with preventCollision if specified\n  if (preventCollision) {\n    return { ...baseCompactor, preventCollision };\n  }\n  return baseCompactor;\n}\n","/**\n * Responsive layout utilities.\n *\n * Functions for handling responsive breakpoints and layout generation.\n */\n\nimport type {\n  Breakpoint,\n  Breakpoints,\n  CompactType,\n  Layout,\n  ResponsiveLayouts\n} from \"./types.js\";\nimport { cloneLayout, correctBounds } from \"./layout.js\";\nimport { compact } from \"./compact-compat.js\";\n\n// ============================================================================\n// Breakpoint Utilities\n// ============================================================================\n\n/**\n * Sort breakpoints by width (ascending).\n *\n * Returns an array of breakpoint names sorted from smallest to largest.\n * E.g., ['xxs', 'xs', 'sm', 'md', 'lg']\n *\n * @param breakpoints - Map of breakpoint names to widths\n * @returns Sorted array of breakpoint names\n */\nexport function sortBreakpoints<B extends Breakpoint>(\n  breakpoints: Breakpoints<B>\n): B[] {\n  const keys = Object.keys(breakpoints) as B[];\n  return keys.sort((a, b) => breakpoints[a] - breakpoints[b]);\n}\n\n/**\n * Get the active breakpoint for a given width.\n *\n * Returns the highest breakpoint that is valid for the width (width > breakpoint).\n *\n * @param breakpoints - Map of breakpoint names to widths\n * @param width - Container width in pixels\n * @returns Active breakpoint name\n */\nexport function getBreakpointFromWidth<B extends Breakpoint>(\n  breakpoints: Breakpoints<B>,\n  width: number\n): B {\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n\n  if (matching === undefined) {\n    throw new Error(\"No breakpoints defined\");\n  }\n\n  for (let i = 1; i < sorted.length; i++) {\n    const breakpointName = sorted[i];\n    if (breakpointName === undefined) continue;\n\n    const breakpointWidth = breakpoints[breakpointName];\n    if (width > breakpointWidth) {\n      matching = breakpointName;\n    }\n  }\n\n  return matching;\n}\n\n/**\n * Get the column count for a breakpoint.\n *\n * @param breakpoint - Breakpoint name\n * @param cols - Map of breakpoint names to column counts\n * @returns Number of columns for the breakpoint\n * @throws Error if breakpoint is not defined in cols\n */\nexport function getColsFromBreakpoint<B extends Breakpoint>(\n  breakpoint: B,\n  cols: Breakpoints<B>\n): number {\n  const colCount = cols[breakpoint];\n  if (colCount === undefined) {\n    throw new Error(\n      `ResponsiveReactGridLayout: \\`cols\\` entry for breakpoint ${String(breakpoint)} is missing!`\n    );\n  }\n  return colCount;\n}\n\n// ============================================================================\n// Layout Generation\n// ============================================================================\n\n/**\n * Find or generate a layout for a breakpoint.\n *\n * If a layout exists for the breakpoint, returns a clone.\n * Otherwise, generates a new layout from the nearest larger breakpoint.\n *\n * @param layouts - Existing layouts by breakpoint\n * @param breakpoints - Breakpoint definitions\n * @param breakpoint - Target breakpoint\n * @param lastBreakpoint - Previous breakpoint (for fallback)\n * @param cols - Column count for the target breakpoint\n * @param compactType - Compaction type\n * @returns Layout for the breakpoint\n */\nexport function findOrGenerateResponsiveLayout<B extends Breakpoint>(\n  layouts: ResponsiveLayouts<B>,\n  breakpoints: Breakpoints<B>,\n  breakpoint: B,\n  lastBreakpoint: B,\n  cols: number,\n  compactType: CompactType\n): Layout {\n  // If it already exists, just return it\n  const existingLayout = layouts[breakpoint];\n  if (existingLayout) {\n    return cloneLayout(existingLayout);\n  }\n\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n\n  // Look for layouts at larger breakpoints\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(\n    breakpointsSorted.indexOf(breakpoint)\n  );\n\n  for (let i = 0; i < breakpointsAbove.length; i++) {\n    const b = breakpointsAbove[i];\n    if (b === undefined) continue;\n\n    const layoutForBreakpoint = layouts[b];\n    if (layoutForBreakpoint) {\n      layout = layoutForBreakpoint;\n      break;\n    }\n  }\n\n  // Clone layout so we don't modify existing items\n  const clonedLayout = cloneLayout(layout || []);\n\n  // Correct bounds and compact\n  return compact(correctBounds(clonedLayout, { cols }), compactType, cols);\n}\n\n// ============================================================================\n// Margin/Padding Helpers\n// ============================================================================\n\ntype IndentationValue<B extends Breakpoint> =\n  | readonly [number, number]\n  | Partial<Record<B, readonly [number, number]>>;\n\n/**\n * Get margin or padding value for a breakpoint.\n *\n * Supports both fixed values ([x, y]) and breakpoint-specific values\n * ({ lg: [x, y], md: [x, y], ... }).\n *\n * @param value - Fixed value or breakpoint-specific map\n * @param breakpoint - Current breakpoint\n * @returns Margin/padding tuple [x, y]\n */\nexport function getIndentationValue<B extends Breakpoint>(\n  value: IndentationValue<B>,\n  breakpoint: B\n): readonly [number, number] {\n  // If it's a tuple (array), return it directly\n  if (Array.isArray(value)) {\n    return value as readonly [number, number];\n  }\n\n  // It's a breakpoint map - find the value\n  const breakpointMap = value as Partial<Record<B, readonly [number, number]>>;\n  const breakpointValue = breakpointMap[breakpoint];\n  if (breakpointValue !== undefined) {\n    return breakpointValue;\n  }\n\n  // Fallback to first defined value\n  const keys = Object.keys(breakpointMap) as B[];\n  for (const key of keys) {\n    const v = breakpointMap[key];\n    if (v !== undefined) {\n      return v;\n    }\n  }\n\n  // Default fallback\n  return [10, 10];\n}\n"]}